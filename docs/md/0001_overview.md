# 教程概览

## Vulkan 的设计哲学

### 历史背景与技术演进
Vulkan 诞生于图形硬件从固定功能管线向可编程架构转型的时代。传统 API（如 OpenGL）在设计时面临的主要挑战包括：

- 硬件抽象层过于厚重
- 驱动程序需要大量猜测工作
- 移动端 GPU 架构差异显著
- 多线程支持不足

**Vulkan 的特性：**  

- **显式控制**：开发者必须明确声明所有操作意图

- **多线程友好**：命令提交与资源创建支持并行处理

- **标准化着色器字节码**：SPIR-V 格式解决跨厂商兼容性问题

- **统一计算/图形管线**：充分利用现代 GPU 的通用计算能力

## 绘制三角形需要什么

*你现在无需记住这些内容，后面会一步一步为你介绍各个组件，你可以随时回顾此内容。*

**核心流程简介：**

1. 实例和物理设备选择
    - API初始化（`VkInstance`）：应用级抽象，管理全局状态
    - 物理硬件（`VkPhysicalDevice`）：物理设备,支持功能和特性的检测
    - 逻辑硬件（`VkDevice`）：逻辑设备，管理资源和操作，关联特定队列族
    - 队列（`VkQueue`）：用于提交命令缓冲

2. 显式窗口表面和交换链
    - 窗口表面（`VkSurfaceKHR`）：跨平台的抽象接口，用于渲染内容到窗口
    - 交换链（`VkSwapchainKHR`）：管理多级缓冲区

3. 图像视图和帧缓冲
    - 图像视图（`VkImageView`）：图像资源的抽象视图，描述图像基本信息
    - 帧缓冲（`VkFramebuffer`）：图像资源和渲染通道连接的桥梁
    - 渲染通道（`VkRenderPass`）：定义渲染过程中各个附件的使用方式

4. 图形管线
    - 着色器模块（`VkShaderModule`）：SPIR-V 字节码加载
    - 图像管线（`VkPipeline`）：定义图形管线的固定功能和可编程着色器阶段

5. 命令执行
    - 命令池（`VkCommandPool`）：用于分配和管理命令缓冲
    - 命令缓冲（`VkCommandBuffer`）：记录渲染操作和命令序列的容器
    - 队列提交：命令缓冲提交到队列中执行，支持异步操作和同步控制

## 开发说明
本教程以C++封装，`vk::raii`为主，使用更加现代的接口，并非底层C风格接口。

所有 Vulkan 函数、枚举和结构都在 `<vulkan/vulkan.hpp>` 和 `<vulkan/vulkan_raii.hpp>` 头文件中定义且都会在vk命名空间中。

C风格接口和Vulkan-hpp封装的差异，我们很快就会介绍。

Vulkan默认命名规范，创建对象的基本范式也会放在后面单独一节内容。

## 验证层(Validation Layer)
Vulkan 采用"默认高性能"的设计哲学，其调试系统具有以下关键特性：

1. 默认情况下，错误检查和调试功能非常有限
2. 允许您通过称为验证层的功能启用广泛的检查
3. 可以在开发期间启用它们，然后在发布应用程序时完全禁用

任何人都可以编写自己的验证层，但 LunarG 的 Vulkan SDK 提供了一组标准的验证层，我们将在本教程中使用它。


