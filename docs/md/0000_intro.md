# 项目介绍

## Vulkan 技术概览

### 什么是 Vulkan？

Vulkan 是 [Khronos Group](https://www.khronos.org/) 推出的**现代图形与计算 API** 。与传统 API （如[OpenGL](https://en.wikipedia.org/wiki/OpenGL)和[Direct3D](https://en.wikipedia.org/wiki/Direct3D)）相比，它为显卡提供了更好的抽象，使你可以更好的描述应用程序的行为，从而带来更好的性能和减少意外的驱动程序行为。

### 与传统API的关键差异

| 维度            | OpenGL/D3D11          | Vulkan               |
|-----------------|----------------------|----------------------|
| 驱动开销        | 高（隐式状态管理）    | 低（显式声明）      |
| 线程模型        | 单线程主导            | 原生多线程支持        |
| 着色器编译      | 运行时GLSL编译        | 预编译SPIR-V字节码    |
| 内存管理        | 驱动自动分配          | 开发者控制内存类型    |

这些好处的代价是您必须使用更细致的 API，每个细节都需要由您的应用程序从头开始设置，这意味着您必须在应用程序中执行更多工作以确保正确的行为。

### 什么人适合Vulkan

 Vulkan 并不适合所有人。它针对的是热衷于高性能计算机图形学并愿意投入一些工作的程序员。

如果您主要对游戏开发感兴趣，那么 OpenGL 或 Direct3D 可能更适合您，因为它们的上手难度相对较低，且在多数场景下仍然能够满足需求。

另一种选择是使用 [Unreal Engine](https://en.wikipedia.org/wiki/Unreal_Engine#Unreal_Engine_4) 或 [Unity](https://en.wikipedia.org/wiki/Unity_(game_engine)) 这样的游戏引擎。这些引擎可以利用 Vulkan 的高性能特性，同时为开发者提供更易用的高级 API，从而在不牺牲太多性能的前提下显著降低开发难度。

## 验证层(Validation Layer)
Vulkan 采用"默认高性能"的设计哲学，其调试系统具有以下关键特性：

1. 默认情况下，错误检查和调试功能非常有限
2. 允许您通过称为验证层的功能启用广泛的检查
3. 可以在开发期间启用它们，然后在发布应用程序时完全禁用

任何人都可以编写自己的验证层，但 LunarG 的 Vulkan SDK 提供了一组标准的验证层，我们将在本教程中使用它。


## 学习前提

### 硬件要求
- 支持 Vulkan 的显卡（NVIDIA/AMD/Intel/Apple Silicon）
- 较新的显卡驱动

### 软件技能

- 熟练的现代 C++ 编程能力（RAII、初始化列表等）
- CMake 和 vcpkg 基础使用经验

### 专业知识
- 线性代数，微积分等数学基础
- 3D 图形学基础知识

本教程不会教你 OpenGL 或 Direct3D 的概念，但它确实要求您了解 计算机图形学 的基础知识。例如，它不会解释透视投影背后的数学原理。  

强烈推荐先修课程： [GAMES101-现代计算机图形学入门](https://www.bilibili.com/video/BV1X7411F744)。  

## 绘制三角形

在编程语言中，常常将打印`Hello World!`作为学习的开始。而图形引擎的学习将从第一个三角形的绘制开始。

### 绘制三角形需要什么

**思考这样一个场景：**

你设计了一些机器人和一些房间用来生产画作。

机器人就是`GPU`，也就是物理设备`VkPhysicalDevice`。

有的机器人不支持画画。有的机器人支持画画，而且有10只机械臂可以画画。有的机械臂不仅能画画，还能扫地。一个机械臂对应一个队列`VkQueue`，它表示GPU的功能。一堆支持特定功能的机械臂称为队列族`VkQueueFamily`，比如绘画队列族。

机器人的型号不一样，但你希望操控的方式一样，于是设计了统一的接口，这就是逻辑设备`VkDevice`。

你希望通过一个屏幕看画（实时渲染），这个屏幕就是第三方的窗口系统，我们使用`GLFW`。

我们需要一个工具，将画作扫描进屏幕，这个扫描仪就是窗口表面`VkSurfaceKHR`。

你看画的速度和机器人画画速度不一样，为了提高效率，可以用一个盒子作为缓冲。机器人往盒子里放画，扫描仪从盒子里拿画。这个盒子就是交换链`VkSwapchainKHR`。

特别的是，这些画画的纸可以重复使用，所以盒子里的纸的总数是固定的。这些纸就是图像`VkImage`，交换链中的图像总数固定。

不同的纸可能有不同的材质和大小，所以我们需要给每个纸写一个标签。这个标签就是图像视图`VkImageView`，描述图像的基本信息。

现在机器人终于可以画画了，我们要为他准备一个画架，用来放画纸。这个画架就是帧缓冲`VkFrameBuffer`，帧就是图像。

我们还要为机器人设计一个房子，房子里放着画笔、颜料等工具，还有一台用于清洗（重置）画纸的机器。这个房子就是渲染通道`VkRenderPass`，这些画笔和机器之类的就是附件`Attachments`。

当画作变得更加复杂，我们可以在一个房子里放多个小房间，每个房间干不同的事情，这些小房间就是子通道`VkSubpass`

机器人很笨，只能看着流程图画画，所以你需要在房间中放置一些流程图，可以是一张，也可以是多张。这个流程图就是图形管线`VkPipeline`。

我们有一份流程图的框架，只需要修改它的部分内容就可以变成新的流程图。其中某几个部分是可编程的，这里就用到了我们熟悉的着色器`Shader`代码。

这些机器人很呆，需要你写信告诉他该画一张画了，在哪个房子哪些房间根据哪些流程图画画。这个信就是命令缓冲`VkCommandBuffer`。你需要先写信才能寄信，我们也必须先录制完命令，然后才能提交。 

特殊的是，这些信可以重用，所以我们使用一个命令池`VkCommandPool`管理这些资源。

事情一多，机器人做起来就乱了，要保证他先画画，画完才能把画拿出去，所以我们用信号量`Semaphore`处理GPU自身的同步。还要保证机器人先完成一张画，我们再寄出新的信，所以我们使用围栏`Fence`处理CPU和GPU之间的同步。

我们还需要初始化一个新的世界，才能在这个世界中建房子写信画流程图，这个新的世界就是Vulkan实例`VkInstance`。

我们的代码要做的，就是创建新世界，然后建房子、花流程图、写信送信······

### 注意

上面的描述是**非常简化**的，与各个模块具体的功能并**不完全一致**。 这有助于初学者的理解，但当你学完具体内容，应当去理解他们更加准确的意义。

由于大量的初始化工作，仅仅是绘制一个三角形就需要接近800行代码。但在后续的过程中，你会逐渐理解以及这些繁琐步骤的巨大意义。且在完成了第一个三角形后，后续扩展纹理和 3D 模型不再需要那么多重复工作。

## 最后

准备好投入高性能图形 API 的未来了吗？ 让我们开始吧！
